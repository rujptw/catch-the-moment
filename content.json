{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://rujptw.github.io/catch-the-moment"},"pages":[{"title":"vue响应式的简单实现","date":"2018-10-17T09:49:39.000Z","updated":"2018-10-17T09:49:39.367Z","comments":true,"path":"vue响应式的简单实现/index.html","permalink":"https://rujptw.github.io/catch-the-moment/vue响应式的简单实现/index.html","excerpt":"","text":""},{"title":"test","date":"2018-10-12T08:27:55.000Z","updated":"2018-10-12T08:27:55.296Z","comments":true,"path":"test/index.html","permalink":"https://rujptw.github.io/catch-the-moment/test/index.html","excerpt":"","text":""},{"title":"怎么使用easymock","date":"2018-10-10T03:38:44.000Z","updated":"2018-10-10T05:52:54.603Z","comments":true,"path":"怎么使用easymock/index.html","permalink":"https://rujptw.github.io/catch-the-moment/怎么使用easymock/index.html","excerpt":"","text":""},{"title":"js的异步","date":"2018-10-10T06:04:06.000Z","updated":"2018-10-10T06:06:52.589Z","comments":true,"path":"js的异步/index.html","permalink":"https://rujptw.github.io/catch-the-moment/js的异步/index.html","excerpt":"","text":""},{"title":"vue的生命周期","date":"2018-10-10T11:01:40.000Z","updated":"2018-10-10T11:01:40.105Z","comments":true,"path":"vue的生命周期/index.html","permalink":"https://rujptw.github.io/catch-the-moment/vue的生命周期/index.html","excerpt":"","text":""}],"posts":[{"title":"vue响应式的简单实现","slug":"vue响应式的简单实现","date":"2018-10-17T09:49:30.000Z","updated":"2018-10-17T10:00:18.712Z","comments":true,"path":"2018/10/17/vue响应式的简单实现/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/17/vue响应式的简单实现/","excerpt":"","text":"关键点：使用Object.defineProperty() 和发布订阅模式实现 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;resource&quot; v-model=&quot;text&quot; /&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;script&gt; function Compile(node, vm) &#123; if (node) &#123; this.$frag = this.nodeToFragment(node, vm); return this.$frag; &#125; &#125; Compile.prototype = &#123; nodeToFragment: function (node, vm) &#123; var self = this; var frag = document.createDocumentFragment(); var child; while (child = node.firstChild) &#123; self.compileElement(child, vm); frag.append(child); // 将所有子节点添加到fragment中 &#125; return frag; &#125;, compileElement: function (node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; //节点类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == &apos;v-model&apos;) &#123; var name = attr[i].nodeValue; // 获取v-model绑定的属性名 node.addEventListener(&apos;input&apos;, function (e) &#123; // 给相应的data属性赋值，进而触发该属性的set方法 vm[name] = e.target.value; &#125;); // node.value = vm[name]; // 将data的值赋给该node new Watcher(vm, node, name, &apos;value&apos;); &#125; &#125; &#125; //节点类型为text if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); // node.nodeValue = vm[name]; // 将data的值赋给该node new Watcher(vm, node, name, &apos;nodeValue&apos;); &#125; &#125; &#125;, &#125; function Dep() &#123; this.subs = []; &#125; Dep.prototype = &#123; addSub: function (sub) &#123; this.subs.push(sub); &#125;, notify: function () &#123; this.subs.forEach(function (sub) &#123; sub.update(); &#125;); &#125; &#125; function Watcher(vm, node, name, type) &#123; Dep.target = this ; this.name = name; this.node = node; this.vm = vm; this.type = type; this.update(); Dep.target = null; &#125; Watcher.prototype = &#123; update: function () &#123; this.get(); this.node[this.type] = this.value; // 订阅者执行相应操作 &#125;, // 获取data的属性值 get: function () &#123; this.value = this.vm[this.name]; //触发相应属性的get &#125; &#125; function defineReactive(obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function () &#123; //添加订阅者watcher到主题对象Dep if (Dep.target) &#123; // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用 dep.addSub(Dep.target); &#125; return val; &#125;, set: function (newVal) &#123; if (newVal === val) return; val = newVal; console.log(val); // 作为发布者发出通知 dep.notify(); &#125; &#125;); &#125; function observe(obj, vm) &#123; Object.keys(obj).forEach(function (key) &#123; defineReactive(vm, key, obj[key]); &#125;); &#125; function Vue(options) &#123; this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom = new Compile(document.getElementById(id), this); // 编译完成后，将dom返回到app中 document.getElementById(id).appendChild(dom); &#125; var vm = new Vue(&#123; el: &apos;app&apos;, data: &#123; text: &apos;hello world&apos; &#125; &#125;); 因为使用到了发布订阅模式,学习了一下，写了个例子 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//通用发布订阅let sendsubscribe = &#123; list:[], listen:function(key,fn)&#123; if(!this.list[key])&#123; this.list[key] = []; &#125; this.list[key].push(fn) &#125;, trigger:function()&#123; let key = Array.prototype.shift.call(arguments);//获取真正想要的下标 let fns = this.list[key]; if(!fns || fns.length === 0)&#123; return; &#125;else&#123; for(let i = 0,fn; fn=fns[i++];)&#123; fn.apply(this,arguments) &#125; &#125; &#125;, remove:function(key,fn)&#123; let fns = this.list[key]; if(!fns)&#123; return false; &#125; if(!fn)&#123; fn&amp;&amp; (fns.length = 0) &#125;else&#123; for(let i = fns.length - 1;i&gt;=0;i--)&#123; let _fn = fns[i]; if(_fn===fn)&#123; fns.splice(i,1) &#125; &#125; &#125; &#125;&#125;//定义函数，让每一个对象都具有发布订阅的能力let initEvent = function(obj)&#123; for(let i in sendsubscribe)&#123; obj[i] = sendsubscribe[i] &#125;&#125;let house = &#123;&#125;;initEvent(house)house.listen(&quot;high-level&quot;,fn1 = function(size,position)&#123; console.log(&quot;面积&quot;,`$&#123;size&#125;,位置 $&#123;position&#125;`);&#125;)house.listen(&quot;price&quot;,fn2 = function(origin,discount)&#123; console.log(&quot;价格&quot;,`$&#123;origin&#125;,折扣,$&#123;discount&#125;`);&#125;)house.remove(&quot;price&quot;,fn2)house.trigger(&quot;price&quot;,&quot;132万&quot;,&quot;80%&quot;)house.trigger(&quot;high-level&quot;,&quot;132平&quot;,&quot;顶层&quot;)","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2018-10-12T08:27:45.000Z","updated":"2018-10-12T08:27:45.749Z","comments":true,"path":"2018/10/12/test/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/12/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"vue的生命周期","date":"2018-10-10T11:00:28.011Z","updated":"2018-10-12T08:21:37.088Z","comments":true,"path":"2018/10/10/vue的生命周期/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/vue的生命周期/","excerpt":"","text":"title: vue的生命周期date: 2018-10-12 16:17:27tags: 生命周期流程图 各个阶段的生命周期钩子函数 beforeCreate:运行此函数时,vue实例处于初始阶段 el,data,methods方法都为undefined,即拿不到 可做loading created:运行此函数时: el为undefined,data,methods方法都可以拿到 可以初始化一些数据 beforeMount:运行此函数时: el为undefined,data,methods方法都可以拿到 mounted:运行此函数时: el,data,methods方法都可以拿到,拿到的Vnode为虚拟dom(待考证) 复杂场景下，必须使用 nextTick才能获取真实的dom 发起请求，避免获取数据为空 beforeUpdate:运行此函数时: el,data,methods方法都可以拿到,但data里的数据已经发生变化,但dom还没有被重新渲染 此时可以对数据进行更改 updated:运行此函数时: el,data,methods方法都可以拿到,data里的数据为前一个钩子时的数据,此时dom已经重新渲染 beforeDestory:运行此函数时: el,data,methods方法都可以拿到 destoryed:运行此函数时: el已经被销毁,data,methods方法都可以拿到,Vue实例被销毁,vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 流程图： 只在keep-alive组件下才能生效的钩子 为什么要用:vue每一次切换路由时都会重新创建组件,但是有时候你想保留上次浏览的状态或者提高性能避免重新渲染都可以用到. 怎么用 123&lt;keep-alive&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt; keep-alive上的属性include和exclude include,会缓存匹配到的组件,例如 include=another,another组件就会被缓存到内存中去，下次切换到该组件就能避免再次渲染 exclude,不会缓存比配到的组件,该组件会经历再次被渲染的过程 actived:运行此函数时: 首次进入组件的该钩子触发顺序在mounted之后,之后再次进入就只会触发actived 想要重新渲染组件可在该钩子上发起请求,此时mounted已经不会触发,数据更新会触发 beforeUpdate和updated钩子 deactived:运行此函数时： 组件被缓存后,离开组件后会触发,此后除了deactived和actived会被触发，其他钩子会处于禁用的状态 后记:得看源码了，不过觉得挺有意思的","categories":[],"tags":[]},{"title":"js的异步","slug":"js的异步","date":"2018-10-10T06:04:15.000Z","updated":"2018-10-10T06:07:44.392Z","comments":true,"path":"2018/10/10/js的异步/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/js的异步/","excerpt":"","text":"JS是单线程的 意义：任务是串行的，只能一步一步地去做。 缺点：可能会造成长时间的等待 怎么解决:异步，能够同时做多项任务,提高了效率，虽然JS是单线程的。 流程：通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。 流程图： 说明： 如上图为事件循环示例图（或JS运行机制图），流程如下 step1: 主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈； step2: 主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）; step3: 异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列； step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）； step5: 重复执行step2、3、4；称为事件循环。 执行的大意：同步环境执行(step1) -&gt; 事件循环1(step4) -&gt; 事件循环2(step4的重复)… 其中的异步进程有： a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中； b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中； c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中 任务队列： 分类: 1. microtask queue 2. macrotask queue 上面的a,b，c均属于macrotask queue，它的api: setTimeout, setInterval, setImmediate, I/O, UI rendering microtask queue 的api:process.nextTick, Promise, MutationObserver macrotask任务会优先于microtask执行,任务队列分为 macrotasks 和 microtasks, 而promise中的then方法的函数会被推入到microtasks队列中，而setTimeout函数会被推入到macrotasks任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 代码为证 1234567891011121314151617console.log(&apos;1, time = &apos; + new Date().toString()) setTimeout(macroCallback, 0); new Promise(function(resolve, reject) &#123; console.log(&apos;2, time = &apos; + new Date().toString()) resolve(); console.log(&apos;3, time = &apos; + new Date().toString()) &#125;).then(microCallback); function macroCallback() &#123; console.log(&apos;4, time = &apos; + new Date().toString()) &#125; function microCallback() &#123; console.log(&apos;5, time = &apos; + new Date().toString()) &#125;依次打印为:1,2,3,5,4 更完整的事件循环流程 将microtask加入到JS运行机制流程中，则： step1、2、3同上， step4：主线程查询任务队列，执行microtask queue，将其按序执行，全部执行完毕； step5：主线程查询任务队列，执行macrotask queue，取队首任务执行，执行完毕； step6：重复step4、step5。 microtask queue中的所有callback处在同一个事件循环中，而macrotask queue中的callback有自己的事件循环。 简而言之：同步环境执行 -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个) -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个)… 利用microtask queue可以形成一个同步执行的环境，但如果Microtask queue太长，将导致Macrotask任务长时间执行不了，最终导致用户I/O无响应等，所以使用需慎重。 为什么要用promise，async: 根据 HTML Standrad， 在每个task运行完以后，UI都会重新渲染，那么在 microCallback完成数据更新，因此当前task结束就可以得到最新的UI了。 反 之：如果新建一个task(例如ajax)来做数据更新的话，那么渲染会执行两次。 参考: JS 事件循环机制 - 任务队列、web API、JS主线程的相互协同 Vue 中如何使用 MutationObserver 做批量处理？ javascript中的异步 macrotask 和 microtask 简介","categories":[],"tags":[]},{"title":"怎么使用easymock","slug":"怎么使用easymock","date":"2018-10-10T03:38:16.000Z","updated":"2018-10-10T06:00:50.525Z","comments":true,"path":"2018/10/10/怎么使用easymock/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/怎么使用easymock/","excerpt":"","text":"easy-mock(模拟数据好用的工具) 注意需要注册才能使用 easy-mock-cli使用文档 为什么要用:只要在网上配置好返回的参数（easy-mock教程）,再加上.easymockrc.js这个配置文件（格式可以多种），它就会帮你自动生成请求文件，到时候就只需调用对应的函数就可以了. 如何使用: cnpm install -g easy-mock-cli 创建配置文件 执行 easymock init . 命令 Bingo,完成了😄","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-10T03:33:48.567Z","updated":"2018-10-10T03:33:48.568Z","comments":true,"path":"2018/10/10/hello-world/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}