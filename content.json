{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://rujptw.github.io/catch-the-moment"},"pages":[{"title":"js的异步","date":"2018-10-10T06:04:06.000Z","updated":"2018-10-10T06:06:52.589Z","comments":true,"path":"js的异步/index.html","permalink":"https://rujptw.github.io/catch-the-moment/js的异步/index.html","excerpt":"","text":""},{"title":"怎么使用easymock","date":"2018-10-10T03:38:44.000Z","updated":"2018-10-10T05:52:54.603Z","comments":true,"path":"怎么使用easymock/index.html","permalink":"https://rujptw.github.io/catch-the-moment/怎么使用easymock/index.html","excerpt":"","text":""}],"posts":[{"title":"js的异步","slug":"js的异步","date":"2018-10-10T06:04:15.000Z","updated":"2018-10-10T06:07:44.392Z","comments":true,"path":"2018/10/10/js的异步/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/js的异步/","excerpt":"","text":"JS是单线程的 意义：任务是串行的，只能一步一步地去做。 缺点：可能会造成长时间的等待 怎么解决:异步，能够同时做多项任务,提高了效率，虽然JS是单线程的。 流程：通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。 流程图： 说明： 如上图为事件循环示例图（或JS运行机制图），流程如下 step1: 主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈； step2: 主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）; step3: 异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列； step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）； step5: 重复执行step2、3、4；称为事件循环。 执行的大意：同步环境执行(step1) -&gt; 事件循环1(step4) -&gt; 事件循环2(step4的重复)… 其中的异步进程有： a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中； b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中； c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中 任务队列： 分类: 1. microtask queue 2. macrotask queue 上面的a,b，c均属于macrotask queue，它的api: setTimeout, setInterval, setImmediate, I/O, UI rendering microtask queue 的api:process.nextTick, Promise, MutationObserver macrotask任务会优先于microtask执行,任务队列分为 macrotasks 和 microtasks, 而promise中的then方法的函数会被推入到microtasks队列中，而setTimeout函数会被推入到macrotasks任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 代码为证 1234567891011121314151617console.log(&apos;1, time = &apos; + new Date().toString()) setTimeout(macroCallback, 0); new Promise(function(resolve, reject) &#123; console.log(&apos;2, time = &apos; + new Date().toString()) resolve(); console.log(&apos;3, time = &apos; + new Date().toString()) &#125;).then(microCallback); function macroCallback() &#123; console.log(&apos;4, time = &apos; + new Date().toString()) &#125; function microCallback() &#123; console.log(&apos;5, time = &apos; + new Date().toString()) &#125;依次打印为:1,2,3,5,4 更完整的事件循环流程 将microtask加入到JS运行机制流程中，则： step1、2、3同上， step4：主线程查询任务队列，执行microtask queue，将其按序执行，全部执行完毕； step5：主线程查询任务队列，执行macrotask queue，取队首任务执行，执行完毕； step6：重复step4、step5。 microtask queue中的所有callback处在同一个事件循环中，而macrotask queue中的callback有自己的事件循环。 简而言之：同步环境执行 -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个) -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个)… 利用microtask queue可以形成一个同步执行的环境，但如果Microtask queue太长，将导致Macrotask任务长时间执行不了，最终导致用户I/O无响应等，所以使用需慎重。 为什么要用promise，async: 根据 HTML Standrad， 在每个task运行完以后，UI都会重新渲染，那么在 microCallback完成数据更新，因此当前task结束就可以得到最新的UI了。 反 之：如果新建一个task(例如ajax)来做数据更新的话，那么渲染会执行两次。 参考: JS 事件循环机制 - 任务队列、web API、JS主线程的相互协同 Vue 中如何使用 MutationObserver 做批量处理？ javascript中的异步 macrotask 和 microtask 简介","categories":[],"tags":[]},{"title":"怎么使用easymock","slug":"怎么使用easymock","date":"2018-10-10T03:38:16.000Z","updated":"2018-10-10T06:00:50.525Z","comments":true,"path":"2018/10/10/怎么使用easymock/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/怎么使用easymock/","excerpt":"","text":"easy-mock(模拟数据好用的工具) 注意需要注册才能使用 easy-mock-cli使用文档 为什么要用:只要在网上配置好返回的参数（easy-mock教程）,再加上.easymockrc.js这个配置文件（格式可以多种），它就会帮你自动生成请求文件，到时候就只需调用对应的函数就可以了. 如何使用: cnpm install -g easy-mock-cli 创建配置文件 执行 easymock init . 命令 Bingo,完成了😄","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-10T03:33:48.567Z","updated":"2018-10-10T03:33:48.568Z","comments":true,"path":"2018/10/10/hello-world/","link":"","permalink":"https://rujptw.github.io/catch-the-moment/2018/10/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}